#include "main.h"

// SOME EXEMPLES
/* ================ CIRCULAR BUFFER ===================
	//Create a circular buffer of 10 slots
	CircularQueue<int> test(10);
	//Create an object so it can be pushed the regular way
	int x = 25;
	if (!test.tryPush(x)) std::cout << "The queue is full, couldn't push x !" << std::endl;
	//Try to push an object created on-the-fly
	if (!test.tryPushRaw(11)) std::cout << "The queue is full, couldn't pushRaw 11 !" << std::endl;
	//Try to pop an object to "out"
	if (test.tryPop(out)) {
		std::cerr << "Debug: " << out << std::endl;
	} else {
		std::cout << "The queue is empty, something went wrong man." << std::endl;
	}
*/

//Obviously, this is the main program.
//At first it prints the welcome screen, bind the server port and start ACE_Reactor coupled with ACE_Acceptor.
//Then it will call ACE_Reactor::run_reactor_event_loop() in a infinite loop (it breaks if ACE returns any error).

int main(int argc, char **argv) {
	//Abnormal termination, such as instigated by the abort function. (Abort.)
	signal(SIGABRT, handle_signal);
	//Erroneous arithmetic operation, such as divide by 0 or overflow. (Floating point exception.)
	signal(SIGFPE, handle_signal);
	//An ‘invalid object program’ has been detected. This usually means that there is an illegal instruction in the program. (Illegal instruction.)
	signal(SIGILL, handle_signal);
	//Interactive attention signal; on interactive systems this is usually generated by typing some ‘break-in’ key at the terminal. (Interrupt.)
	signal(SIGINT, handle_signal);
	//Invalid storage access; most frequently caused by attempting to store some value in an object pointed to by a bad pointer. (Segment violation.)
	signal(SIGSEGV, handle_signal);
	//Termination request made to the program. (Terminate.)
	signal(SIGTERM, handle_signal);

	//=========================================
    // STARTUP MESSAGE
    //=========================================
    std::cout <<
	"NN      NN  NN      NN NN    NN             "   << std::endl <<
	"NNNN    NN  NNNN    NN  NN  NN        NNNNN "   << std::endl <<
	"NN NN   NN  NN NN   NN   NNNN            NN "   << std::endl <<
	"NN  NN  NN  NN  NN  NN    NN  NN    NN  NN  "   << std::endl <<
	"NN   NN NN  NN   NN NN    NN  NN   NN  NNN  "   << std::endl <<
	"NN    NNNN  NN    NNNN    NN   NN NN     NN "   << std::endl <<
	"NN     NNN  NN     NNN    NN    NNN   NNNN  "   << std::endl <<
	"-------------------------------"				 << std::endl <<
	"- Type: Realm server"							 << std::endl <<
	"- Protocol version: " << NNY_PROTOCOL_VERSION   << std::endl <<
	"- MySQL version: " << MYSQL_SERVER_VERSION		 << std::endl <<
	"-------------------------------"				 << std::endl;
	
	//=========================================
    //      SETTING UP THE DATABASE
    //=========================================
	//======== LOAD THE LIBRARY TO MEMORY
	database::load();
	//======== Initialization
	database::connection db = database::init();
	//======== Connection
	if (!database::connect(db, "localhost", "nnyv3", "", "nnyv3", 3306)) {
		std::cout << "We were unable to contact the MySQL database!" << std::endl;
		pauseExit();
	} else {
		std::cout << "Connected to the MySQL database." << std::endl;
	}
	//======== Sending a query and saving the result
	database::result db_result = database::query(db, "SELECT version_nb FROM version", database::STORE_RESULT);
	//======== Now we can check the result like this
	if (db_result) {
		database::row row = database::fetch_row(db_result); //there's only one row, we don't need a loop here
		int version_nb = database::toInt(row[0]);
		if (version_nb != CONFIG_SUPPORTED_DATABASE) {
			std::cout << "This server supports only the v" << CONFIG_SUPPORTED_DATABASE << " database; yours is still using v" << version_nb << "." << std::endl;
			pauseExit();
		}
	}
	//======== Freeing memory as soon as possible
	database::free_result(db_result);

	//=========================================
    // SETTING UP : `ACE_Acceptor`
    //=========================================
    std::cout << "Setting up acceptor..." << std::endl;
	
	// Server port number.
	const u_short port = 6131;
	ACE_INET_Addr server_addr(port);
	
	// Initialize server endpoint an register with the Reactor.
	ACE_Acceptor<PacketHandler,ACE_SOCK_ACCEPTOR> acceptor(server_addr, ACE_Reactor::instance(), ACE_NONBLOCK);

	//=========================================
    // MAIN PROGRAM LOOP : `ACE_Reactor`
    // It handles ACE_Acceptor events (like connections/deconnections) and incoming packets.
    //=========================================
	
	// Main event loop that handles packets
	std::cout << "Server is now running!" << std::endl;
	while(true) {
		// dont move this outside the loop, the reactor will modify it
        //ACE_Time_Value interval(0, 100000);

		//ACE_Reactor::instance()->handle_events();
        //if (ACE_Reactor::instance()->run_reactor_event_loop(interval) == -1)
		if (ACE_Reactor::instance()->run_reactor_event_loop() == -1) {
			std::cout << "[Debug] Reactor event loop broken! What happened?!" << std::endl;
			break;
		}
	}

    //===================================
    // EXIT
    //===================================
    return 0;
}

void pauseExit() {
	while (true) ACE_OS::sleep(ACE_Time_Value(1));
}

void handle_signal(int signal) {
	std::cout << "SINGAL RECEIVED: " << signal << std::endl;
	//Close the mysql connection
	database::close(db);
	//Unload the library from memory (allocated earlier)
	database::unload();
	//Exiting
	exit(signal);
}