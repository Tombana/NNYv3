#include "main.h"

//REALM SERVER

//!!!!!!!!!!!!!!!!!!!!!! =[ GLOBAL VARS ]= !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
database::connection g_db			  = database::init(); //Prepare a connection to the database
unsigned int		 g_client_version = 4; //This default value will be overrided in main()
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

//Obviously, this is the main program.
//At first it prints the welcome screen, bind the server port and start ACE_Reactor coupled with ACE_Acceptor.
//Then it will call ACE_Reactor::run_reactor_event_loop() in a infinite loop (it breaks if ACE returns any error).
int main(int argc, char **argv) {
	//=========================================
    // SETUP SIGNALS HANDLING
    //=========================================
	//Abnormal termination, such as instigated by the abort function. (Abort.)
	signal(SIGABRT, handle_signal);
	//Erroneous arithmetic operation, such as divide by 0 or overflow. (Floating point exception.)
	signal(SIGFPE, handle_signal);
	//An ‘invalid object program’ has been detected. This usually means that there is an illegal instruction in the program. (Illegal instruction.)
	signal(SIGILL, handle_signal);
	//Interactive attention signal; on interactive systems this is usually generated by typing some ‘break-in’ key at the terminal. (Interrupt.)
	signal(SIGINT, handle_signal);
	//Invalid storage access; most frequently caused by attempting to store some value in an object pointed to by a bad pointer. (Segment violation.)
	signal(SIGSEGV, handle_signal);
	//Termination request made to the program. (Terminate.)
	signal(SIGTERM, handle_signal);

	//=========================================
    // STARTUP MESSAGE
    //=========================================
    std::cout <<
	"NN      NN  NN      NN NN    NN             "   << std::endl <<
	"NNNN    NN  NNNN    NN  NN  NN        NNNNN "   << std::endl <<
	"NN NN   NN  NN NN   NN   NNNN            NN "   << std::endl <<
	"NN  NN  NN  NN  NN  NN    NN  NN    NN  NN  "   << std::endl <<
	"NN   NN NN  NN   NN NN    NN  NN   NN  NNN  "   << std::endl <<
	"NN    NNNN  NN    NNNN    NN   NN NN     NN "   << std::endl <<
	"NN     NNN  NN     NNN    NN    NNN   NNNN  "   << std::endl <<
	"-------------------------------"                << std::endl <<
	"- Type: Realm server"                           << std::endl <<
	"- Protocol version: " << NNY_PROTOCOL_VERSION   << std::endl <<
	"- MySQL version: " << MYSQL_SERVER_VERSION      << std::endl <<
	"-------------------------------"                << std::endl;
	
    //=========================================
    //      SETTING UP THE DATABASE
    //=========================================
	//======== Connection
	if (!database::connect(g_db, "127.0.0.1", "nnyv3", "", "nnyv3", 3306)) {
		std::cout << "We were unable to contact the MySQL database!" << std::endl;
        } else {
		std::cout << "Connected to the MySQL database." << std::endl;
	}
    //======== Send a query and save the result
	database::result db_result = database::query(g_db, "SELECT version_r FROM version", database::STORE_RESULT);
	//======== Now we can check the result like this
	if (db_result) {
		database::row row = database::fetch_row(db_result); //there's only one row, we don't need a loop here
		int version_nb = database::toInt(row[0]);
		if (version_nb != CONFIG_DATABASE_VERSION_REALM) {
			std::cout << "This server supports only the v" << CONFIG_DATABASE_VERSION_REALM << " realm database; yours is still using v" << version_nb << "." << std::endl;
			//Sleep forever
			forever ACE_OS::sleep(ACE_Time_Value(1));
		}
		database::free_result(db_result);
	}

	//=========================================
    // SETTING UP WORLDLINK MANAGER
    //=========================================
	std::cout << "Setting up the world server list..." << std::endl;
	WORLDLINKMGR::instance()->loadWorldsFromDB(g_db);

	//=========================================
    // SETTING UP PACKET DISPATCHER
    //=========================================
	std::cout << "Setting up the packet dispatcher..." << std::endl;
	//Calling ACE_Singleton to get a pointer of our instance everytime would be stupid, once is enough.
	PacketDispatcher<SESSION> *i_dispatcher = PACKETDISPATCHER::instance();
	//Add sources to the dispatcher instance; btw the class destructor will make sure to delete created objects
	i_dispatcher->addSource(PCKT_X_DEBUG, new CapsuleDebug);
	i_dispatcher->addSource(PCKT_C_VERSION, new CapsuleVersion);
	i_dispatcher->addSource(PCKT_C_GETWORLDLIST, new CapsuleWorldlist);
	i_dispatcher->addSource(PCKT_W_SYNC_KEY, new CapsuleSync);

	//=========================================
    // SETTING UP : `ACE_Acceptor`
    //=========================================
    std::cout << "Setting up acceptor on port 6131..." << std::endl;
	
	//Server port number.
	ACE_INET_Addr server_addr(6131);
	
	//Initialize server endpoint an register with the Reactor.
	ACE_Acceptor<PacketHandler,ACE_SOCK_ACCEPTOR> acceptor(server_addr, ACE_Reactor::instance(), ACE_NONBLOCK);

	//=========================================
    // MAIN PROGRAM LOOP : `ACE_Reactor`
    // It handles ACE_Acceptor events (like connections/deconnections) and incoming packets.
    //=========================================
	
	// Main event loop that handles packets
	std::cout << "Server is now running!" << std::endl;
	forever {
		// dont move this outside the loop, the reactor will modify it
        //ACE_Time_Value interval(0, 100000);

		//ACE_Reactor::instance()->handle_events();
        //if (ACE_Reactor::instance()->run_reactor_event_loop(interval) == -1)
		if (ACE_Reactor::instance()->run_reactor_event_loop() == -1) {
			std::cout << "[Debug] Reactor event loop broken! What happened?!" << std::endl;
			break;
		}
	}

    //===================================
    // EXIT
    //===================================
    return EXIT_SUCCESS;
}

void handle_signal(int signal) {
	std::cout << "SINGAL RECEIVED: " << signal << std::endl;
	//Never close the mysql connection unless it's REALLY needed, like now
	database::close(g_db);
	//Unload the library from memory; allocated earlier from mysql_init()
	database::unload();
	//Exiting
	std::cout << "Exiting..." << std::endl;
	exit(signal);
}
